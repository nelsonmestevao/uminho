-- ========================================================================== --
-- Programação Funcional                                            2017/2018 --
-- Questões 1ª Parte                                                          --
-- ========================================================================== --
module Q1_1718 where

import Data.Char
import Data.Either
import Data.List

--------------------------------------------------------------------------------
-- Questão 1 --
--------------------------------------------------------------------------------
myenumFromTo :: Int -> Int -> [Int]
myenumFromTo x y
  | x >= y = [y]
  | x < y = x : myenumFromTo (x + 1) y

--------------------------------------------------------------------------------
-- Questão 2 --
--------------------------------------------------------------------------------
myenumFromThenTo :: Int -> Int -> Int -> [Int]
myenumFromThenTo a k b
  | a < k && a < b = a : myenumFromThenTo k (k + (k - a)) b
  | a == b = [a]
  | a == k = repeat a
  | otherwise = []

--------------------------------------------------------------------------------
-- Questão 3 --
--------------------------------------------------------------------------------
concatena :: [a] -> [a] -> [a]
concatena [] l = l
concatena (x:xs) l = x : concatena xs l

--------------------------------------------------------------------------------
-- Questão 4 --
--------------------------------------------------------------------------------
(!!!) :: [a] -> Int -> a
(!!!) (x:xs) 0 = x
(!!!) (x:xs) n = (!!!) xs (n - 1)

--------------------------------------------------------------------------------
-- Questão 5 --
--------------------------------------------------------------------------------
myreverse :: [a] -> [a]
myreverse [] = []
myreverse (x:xs) = myreverse xs ++ [x]

--------------------------------------------------------------------------------
-- Questão 6 --
--------------------------------------------------------------------------------
mytake :: Int -> [a] -> [a]
mytake 0 l = []
mytake n [] = []
mytake n (x:xs) = x : mytake (n - 1) xs

--------------------------------------------------------------------------------
-- Questão 7 --
--------------------------------------------------------------------------------
mydrop :: Int -> [a] -> [a]
mydrop 0 l = l
mydrop _ [] = []
mydrop n (x:xs)
  | n > 0 = mydrop (n - 1) xs

--------------------------------------------------------------------------------
-- Questão 8 --
--------------------------------------------------------------------------------
myzip :: [a] -> [b] -> [(a, b)]
myzip (x:xs) (y:ys) = (x, y) : myzip xs ys
myzip _ _ = []

--------------------------------------------------------------------------------
-- Questão 9 --
--------------------------------------------------------------------------------
myelem :: Eq a => a -> [a] -> Bool
myelem e [] = False
myelem e (x:xs) = e == x || myelem e xs

--------------------------------------------------------------------------------
-- Questão 10 --
--------------------------------------------------------------------------------
myreplicate :: Int -> a -> [a]
myreplicate 0 _ = []
myreplicate n b = b : myreplicate (n - 1) b

--------------------------------------------------------------------------------
-- Questão 11 --
--------------------------------------------------------------------------------
myintersperse :: a -> [a] -> [a]
myintersperse _ [x] = [x]
myintersperse n (x:xs) = x : n : myintersperse n xs

--------------------------------------------------------------------------------
-- Questão 12 --
--------------------------------------------------------------------------------
mygroup :: Eq a => [a] -> [[a]]
mygroup [] = [[]]
mygroup (h:t) = aux [h] t
  where
    aux a [] = [a]
    aux a (h:t)
      | elem h a = aux (h : a) t
      | otherwise = a : aux [h] t

--------------------------------------------------------------------------------
-- Questão 13 --
--------------------------------------------------------------------------------
myconcat :: [[a]] -> [a]
myconcat [] = []
myconcat (x:xs) = x ++ myconcat xs

--------------------------------------------------------------------------------
-- Questão 14 --
--------------------------------------------------------------------------------
myinits :: [a] -> [[a]]
myinits [] = [[]]
myinits l = myinits (init l) ++ [l]

--------------------------------------------------------------------------------
-- Questão 15 --
--------------------------------------------------------------------------------
mytails :: [a] -> [[a]]
mytails [] = [[]]
mytails l = [l] ++ mytails (tail l)

--------------------------------------------------------------------------------
-- Questão 16 --
--------------------------------------------------------------------------------
myisPrefixOf :: Eq a => [a] -> [a] -> Bool
myisPrefixOf [] _ = True
myisPrefixOf (x:xs) (y:ys) =
  if x == y
    then myisPrefixOf xs ys
    else False

--------------------------------------------------------------------------------
-- Questão 17 --
--------------------------------------------------------------------------------
myisSuffixOf :: Eq a => [a] -> [a] -> Bool
myisSuffixOf [] _ = True
myisSuffixOf l1 l2 =
  if (last l1) == (last l2)
    then myisSuffixOf (init l1) (init l2)
    else False

--------------------------------------------------------------------------------
-- Questão 18 --
--------------------------------------------------------------------------------
myisSubsequenceOf :: Eq a => [a] -> [a] -> Bool
myisSubsequenceOf [] _ = True
myisSubsequenceOf _ [] = False
myisSubsequenceOf (x:xs) (y:ys) =
  if x == y
    then myisSubsequenceOf xs ys
    else myisSubsequenceOf (x : xs) ys

--------------------------------------------------------------------------------
-- Questão 19 --
--------------------------------------------------------------------------------
myelemIndices :: Eq a => a -> [a] -> [Int]
myelemIndices _ [] = []
myelemIndices x l = aux 0 x l
  where
    aux _ _ [] = []
    aux i x (h:t) =
      if x == h
        then i : aux (i + 1) x t
        else aux (i + 1) x t

--------------------------------------------------------------------------------
-- Questão 20 --
--------------------------------------------------------------------------------
mynub :: Eq a => [a] -> [a]
mynub [] = []
mynub (h:t) = h : mynub (aux h t)
  where
    aux _ [] = []
    aux x (y:ys) =
      if x == y
        then aux x ys
        else y : aux x ys

--------------------------------------------------------------------------------
-- Questão 21 --
--------------------------------------------------------------------------------
mydelete :: Eq a => a -> [a] -> [a]
mydelete _ [] = []
mydelete x (h:t) =
  if x == h
    then t
    else h : mydelete x t

--------------------------------------------------------------------------------
-- Questão 22 --
--------------------------------------------------------------------------------
(\\\\) :: Eq a => [a] -> [a] -> [a]
(\\\\) l [] = l
(\\\\) [] _ = []
(\\\\) l (y:ys) = (\\\\) (delete y l) ys

--------------------------------------------------------------------------------
-- Questão 23 --
--------------------------------------------------------------------------------
myunion :: Eq a => [a] -> [a] -> [a]
myunion [] l = l
myunion l [] = l
myunion l (x:xs)
  | elem x l = myunion l xs
  | otherwise = myunion (l ++ [x]) xs

--------------------------------------------------------------------------------
-- Questão 24 --
--------------------------------------------------------------------------------
myintersect :: Eq a => [a] -> [a] -> [a]
myintersect [] _ = []
myintersect (x:xs) l
  | elem x l = x : myintersect xs l
  | otherwise = myintersect xs l

--------------------------------------------------------------------------------
-- Questão 25 --
--------------------------------------------------------------------------------
myinsert :: Ord a => a -> [a] -> [a]
myinsert x [] = [x]
myinsert x (h:t)
  | x <= h = x : h : t
  | x > h = h : myinsert x t

--------------------------------------------------------------------------------
-- Questão 26 --
--------------------------------------------------------------------------------
myunwords :: [String] -> String
myunwords [] = ""
myunwords [x] = x
myunwords (h:t) = h ++ [' '] ++ myunwords t

--------------------------------------------------------------------------------
-- Questão 27 --
--------------------------------------------------------------------------------
myunlines :: [String] -> String
myunlines [] = ""
myunlines [x] = x ++ "\n"
myunlines (h:t) = h ++ "\n" ++ myunlines t

--------------------------------------------------------------------------------
-- Questão 28 --
--------------------------------------------------------------------------------
pMaior :: Ord a => [a] -> Int
pMaior [x] = 0
pMaior (h:t)
  | h == aux (h : t) = 0
  | otherwise = 1 + pMaior t
  where
    aux [x] = x
    aux (x:y:xs)
      | x >= y = aux (x : xs)
      | otherwise = aux (y : xs)

--------------------------------------------------------------------------------
-- Questão 29 --
---------------------- ----------------------------------------------------------
temRepetidos :: Eq a => [a] -> Bool
temRepetidos [] = False
temRepetidos (h:t) = elem h t || temRepetidos t

--------------------------------------------------------------------------------
-- Questão 30 --
--------------------------------------------------------------------------------
algarismos :: [Char] -> [Char]
algarismos [] = []
algarismos (h:t)
  | isDigit h = h : algarismos t
  | otherwise = algarismos t

--------------------------------------------------------------------------------
-- Questão 31 --
--------------------------------------------------------------------------------
posImpares :: [a] -> [a]
posImpares [] = []
posImpares l = aux False l
  where
    aux _ [] = []
    aux True (h:t) = h : aux False t
    aux False (h:t) = aux True t

--------------------------------------------------------------------------------
-- Questão 32 --
--------------------------------------------------------------------------------
posPares :: [a] -> [a]
posPares [] = []
posPares l = aux True l
  where
    aux _ [] = []
    aux True (h:t) = h : aux False t
    aux False (h:t) = aux True t

--------------------------------------------------------------------------------
-- Questão 33 --
--------------------------------------------------------------------------------
isSorted :: Ord a => [a] -> Bool
isSorted [] = True
isSorted [x] = True
isSorted (x:y:xs)
  | x > y = False
  | otherwise = isSorted (y : xs)

--------------------------------------------------------------------------------
-- Questão 34 --
--------------------------------------------------------------------------------
iSort :: Ord a => [a] -> [a]
iSort [] = []
iSort (h:t) = insert h (iSort t)

--------------------------------------------------------------------------------
-- Questão 35 --
--------------------------------------------------------------------------------
menor :: String -> String -> Bool
menor _ [] = False
menor [] _ = True
menor (x:xs) (y:ys)
  | ord x < ord y = True
  | ord x > ord y = False
  | otherwise = menor xs ys

--------------------------------------------------------------------------------
-- Questão 36 --
--------------------------------------------------------------------------------
elemMSet :: Eq a => a -> [(a, Int)] -> Bool
elemMSet x [] = False
elemMSet x ((y, n):ys)
  | x == y = True
  | otherwise = elemMSet x ys

--------------------------------------------------------------------------------
-- Questão 37 --
--------------------------------------------------------------------------------
lengthMSet :: [(a, Int)] -> Int
lengthMSet [] = 0
lengthMSet ((y, n):ys) = n + lengthMSet ys

--------------------------------------------------------------------------------
-- Questão 38 --
--------------------------------------------------------------------------------
converteMSet :: [(a, Int)] -> [a]
converteMSet [] = []
converteMSet ((y, n):ys) = aux (y, n) ++ converteMSet ys
  where
    aux (y, 0) = []
    aux (y, n) = [y] ++ aux (y, n - 1)

--------------------------------------------------------------------------------
-- Questão 39 --
--------------------------------------------------------------------------------
insereMSet :: Eq a => a -> [(a, Int)] -> [(a, Int)]
insereMSet e [] = [(e, 1)]
insereMSet e ((y, n):ys)
  | e == y = ((y, n + 1) : ys)
  | otherwise = (y, n) : insereMSet e ys

--------------------------------------------------------------------------------
-- Questão 40 --
--------------------------------------------------------------------------------
removeMSet :: Eq a => a -> [(a, Int)] -> [(a, Int)]
removeMSet _ [] = []
removeMSet e ((y, n):ys)
  | (e == y) && (n > 1) = ((y, n - 1) : ys)
  | (e == y) && (n == 1) = ys
  | otherwise = (y, n) : removeMSet e ys

--------------------------------------------------------------------------------
-- Questão 41 --
--------------------------------------------------------------------------------
constroiMSet :: Ord a => [a] -> [(a, Int)]
constroiMSet l = aux 1 l
  where
    aux i [x] = [(x, i)]
    aux i (x:y:xs)
      | x == y = aux (i + 1) (x : xs)
      | x /= y = (x, i) : aux 1 (y : xs)

--------------------------------------------------------------------------------
-- Questão 42 --
--------------------------------------------------------------------------------
mypartitionEithers :: [Either a b] -> ([a], [b])
mypartitionEithers l = (left l, right l)
  where
    left (Left a:t) = a : left t
    left (Right b:t) = left t
    left _ = []
    right (Left a:t) = right t
    right (Right a:t) = a : right t
    right _ = []

--------------------------------------------------------------------------------
-- Questão 43 --
--------------------------------------------------------------------------------
catMaybes :: [Maybe a] -> [a]
catMaybes [] = []
catMaybes (Just a:xs) = a : catMaybes xs
catMaybes (Nothing:xs) = catMaybes xs

--------------------------------------------------------------------------------
-- Questão 44 --
--------------------------------------------------------------------------------
data Movimento
  = Norte
  | Sul
  | Este
  | Oeste
  deriving (Show)

posicao :: (Int, Int) -> [Movimento] -> (Int, Int)
posicao (x, y) [] = (x, y)
posicao (x, y) (Norte:r) = posicao (x, y + 1) r
posicao (x, y) (Sul:r) = posicao (x, y - 1) r
posicao (x, y) (Este:r) = posicao (x + 1, y) r
posicao (x, y) (Oeste:r) = posicao (x - 1, y) r

--------------------------------------------------------------------------------
-- Questão 45 --
--------------------------------------------------------------------------------
caminho :: (Int, Int) -> (Int, Int) -> [Movimento]
caminho (x1, y1) (x2, y2)
  | x1 == x2 && y1 == y2 = []
  | x1 < x2 = [Este] ++ caminho (x1 + 1, y1) (x2, y2)
  | x1 > x2 = [Oeste] ++ caminho (x1, y1) (x2 + 1, y2)
  | y1 < y2 = [Norte] ++ caminho (x1, y1 + 1) (x2, y2)
  | y1 > y2 = [Sul] ++ caminho (x1, y1) (x2, y2 + 1)

--------------------------------------------------------------------------------
-- Questão 46 --
--------------------------------------------------------------------------------
vertical :: [Movimento] -> Bool
vertical [] = True
vertical (Norte:xs) = vertical xs
vertical (Sul:xs) = vertical xs
vertical _ = False

--------------------------------------------------------------------------------
-- Questão 47 --
--------------------------------------------------------------------------------
data Posicao =
  Pos Int Int
  deriving (Show)

maisCentral :: [Posicao] -> Posicao
maisCentral [x] = x
maisCentral (x:y:t)
  | aux x <= aux y = maisCentral (x : t)
  | aux x > aux y = maisCentral (y : t)
  where
    aux (Pos k m) = sqrt (fromIntegral (k ^ 2 + m ^ 2))

--------------------------------------------------------------------------------
-- Questão 48 --
--------------------------------------------------------------------------------
vizinhos :: Posicao -> [Posicao] -> [Posicao]
vizinhos _ [] = []
vizinhos (Pos x y) ((Pos z w):t) =
  if (y == w && x == (z + 1)) ||
     (y == w && x == (z - 1)) ||
     (x == z && y == (w + 1)) || (x == z && y == (w - 1))
    then (Pos z w) : vizinhos (Pos x y) t
    else vizinhos (Pos x y) t

--------------------------------------------------------------------------------
-- Questão 49 --
--------------------------------------------------------------------------------
mesmaOrdenada :: [Posicao] -> Bool
mesmaOrdenada [x] = True
mesmaOrdenada ((Pos x y):(Pos z w):t) =
  if y == w
    then mesmaOrdenada ((Pos z w) : t)
    else False

--------------------------------------------------------------------------------
-- Questão 50 --
--------------------------------------------------------------------------------
data Semaforo
  = Verde
  | Amarelo
  | Vermelho
  deriving (Show)

interseccaoOK :: [Semaforo] -> Bool
interseccaoOK l = aux l <= 1
  where
    aux [Vermelho] = 0
    aux [Verde] = 1
    aux [Amarelo] = 1
    aux (Vermelho:resto) = aux resto
    aux (Verde:resto) = 1 + aux resto
    aux (Amarelo:resto) = 1 + aux resto
