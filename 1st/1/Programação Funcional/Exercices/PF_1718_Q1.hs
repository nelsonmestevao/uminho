-- ========================================================================== --
-- Programação Funcional                                            2017/2018 --
-- Questões 1ª Parte                                                          --
-- ========================================================================== --

module Q1_1718 where

import Data.Char
import Data.List
import Data.Either

--------------------------------------------------------------------------------
-- Questão 1 --
--------------------------------------------------------------------------------

myenumFromTo :: Int -> Int -> [Int]
myenumFromTo x y | x >= y = [y]
                 | x < y  = x:(myenumFromTo (x+1) y)

--------------------------------------------------------------------------------
-- Questão 2 --
--------------------------------------------------------------------------------

myenumFromThenTo :: Int -> Int -> Int -> [Int]
myenumFromThenTo a k b | a<k && a<b = a:myenumFromThenTo k (k+(k-a)) b
                       | a==b       = [a]
                       | a==k       = repeat a
                       | otherwise  = []

--------------------------------------------------------------------------------
-- Questão 3 --
--------------------------------------------------------------------------------

concatena :: [a] -> [a] -> [a]
concatena [] l     = l
concatena (x:xs) l = x:concatena xs l

--------------------------------------------------------------------------------
-- Questão 4 --
--------------------------------------------------------------------------------

(!!!) :: [a] -> Int -> a
(!!!) (x:xs) 0 = x
(!!!) (x:xs) n = (!!!) xs (n-1)

--------------------------------------------------------------------------------
-- Questão 5 --
--------------------------------------------------------------------------------

myreverse :: [a] -> [a]
myreverse []     = []
myreverse (x:xs) = (myreverse xs) ++ [x]

--------------------------------------------------------------------------------
-- Questão 6 --
--------------------------------------------------------------------------------

mytake :: Int -> [a] -> [a]
mytake 0 l      = []
mytake n []     = []
mytake n (x:xs) = x:mytake (n-1) xs

--------------------------------------------------------------------------------
-- Questão 7 --
--------------------------------------------------------------------------------

mydrop :: Int -> [a] -> [a]
mydrop 0 l            = l
mydrop _ []           = []
mydrop n (x:xs) | n>0 = mydrop (n-1) xs

--------------------------------------------------------------------------------
-- Questão 8 --
--------------------------------------------------------------------------------

myzip :: [a] -> [b] -> [(a,b)]
myzip (x:xs) (y:ys) = (x,y) : myzip xs ys
myzip _ _           = []

--------------------------------------------------------------------------------
-- Questão 9 --
--------------------------------------------------------------------------------

myelem :: Eq a => a -> [a] -> Bool
myelem e []     = False
myelem e (x:xs) = e == x || myelem e xs

--------------------------------------------------------------------------------
-- Questão 10 --
--------------------------------------------------------------------------------

myreplicate :: Int -> a -> [a]
myreplicate 0 _ = []
myreplicate n b = b:myreplicate (n-1) b

--------------------------------------------------------------------------------
-- Questão 11 --
--------------------------------------------------------------------------------

myintersperse :: a -> [a] -> [a]
myintersperse _ [x]    = [x]
myintersperse n (x:xs) = x:n:myintersperse n xs

--------------------------------------------------------------------------------
-- Questão 12 --
--------------------------------------------------------------------------------

mygroup :: Eq a => [a] -> [[a]]
mygroup []    = [[]]
mygroup (h:t) = aux [h] t
              where
                aux a [] = [a]
                aux a (h:t) | elem h a = aux (h:a) t
                            | otherwise = a :aux [h] t

--------------------------------------------------------------------------------
-- Questão 13 --
--------------------------------------------------------------------------------

myconcat :: [[a]] -> [a]
myconcat []     = []
myconcat (x:xs) = x ++ myconcat xs

--------------------------------------------------------------------------------
-- Questão 14 --
--------------------------------------------------------------------------------

myinits :: [a] -> [[a]]
myinits [] = [[]]
myinits l  = myinits(init l) ++ [l]

--------------------------------------------------------------------------------
-- Questão 15 --
--------------------------------------------------------------------------------

mytails :: [a] -> [[a]]
mytails [] = [[]]
mytails l  = [l] ++ mytails (tail l)

--------------------------------------------------------------------------------
-- Questão 16 --
--------------------------------------------------------------------------------

myisPrefixOf :: Eq a => [a] -> [a] -> Bool
myisPrefixOf [] _ = True
myisPrefixOf (x:xs) (y:ys) = if x==y
                             then myisPrefixOf xs ys
                             else False

--------------------------------------------------------------------------------
-- Questão 17 --
--------------------------------------------------------------------------------

myisSuffixOf :: Eq a => [a] -> [a] -> Bool
myisSuffixOf [] _  = True
myisSuffixOf l1 l2 = if (last l1) == (last l2)
                     then myisSuffixOf (init l1) (init l2)
                     else False

--------------------------------------------------------------------------------
-- Questão 18 --
--------------------------------------------------------------------------------

myisSubsequenceOf :: Eq a => [a] -> [a] -> Bool
myisSubsequenceOf [] _ = True
myisSubsequenceOf _ [] = False
myisSubsequenceOf (x:xs) (y:ys) = if x==y
                                  then myisSubsequenceOf xs ys
                                  else myisSubsequenceOf (x:xs) ys

--------------------------------------------------------------------------------
-- Questão 19 --
--------------------------------------------------------------------------------

myelemIndices :: Eq a => a -> [a] -> [Int]
myelemIndices _ [] = []
myelemIndices x l  = aux 0 x l
                  where
                    aux _ _ [] = []
                    aux i x (h:t) = if x==h
                                    then i:aux (i+1) x t
                                    else aux (i+1) x t

--------------------------------------------------------------------------------
-- Questão 20 --
--------------------------------------------------------------------------------

mynub :: Eq a => [a] -> [a]
mynub []    = []
mynub (h:t) = h: mynub (aux h t)
            where
              aux _ [] = []
              aux x (y:ys) = if x==y
                             then aux x ys
                             else y:aux x ys

--------------------------------------------------------------------------------
-- Questão 21 --
--------------------------------------------------------------------------------

mydelete :: Eq a => a -> [a] -> [a]
mydelete _ []    = []
mydelete x (h:t) = if x==h
                   then t
                   else h:mydelete x t

--------------------------------------------------------------------------------
-- Questão 22 --
--------------------------------------------------------------------------------

(\\\\) :: Eq a => [a] -> [a] -> [a]
(\\\\) l [] = l
(\\\\) [] _ = []
(\\\\) l (y:ys) = (\\\\) (delete y l) ys

--------------------------------------------------------------------------------
-- Questão 23 --
--------------------------------------------------------------------------------

myunion :: Eq a => [a] -> [a] -> [a]
myunion [] l = l
myunion l [] = l
myunion l (x:xs) | elem x l  = myunion l xs
                 | otherwise = myunion (l ++ [x]) xs


--------------------------------------------------------------------------------
-- Questão 24 --
--------------------------------------------------------------------------------

myintersect :: Eq a => [a] -> [a] -> [a]
myintersect [] _ = []
myintersect (x:xs) l | elem x l  = x:myintersect xs l
                     | otherwise = myintersect xs l

--------------------------------------------------------------------------------
-- Questão 25 --
--------------------------------------------------------------------------------

myinsert :: Ord a => a -> [a] -> [a]
myinsert x [] = [x]
myinsert x (h:t) | x <= h = x:h:t
                 | x>h    = h:myinsert x t

--------------------------------------------------------------------------------
-- Questão 26 --
--------------------------------------------------------------------------------

myunwords :: [String] -> String
myunwords []    = ""
myunwords [x]   = x
myunwords (h:t) = h++[' ']++myunwords t

--------------------------------------------------------------------------------
-- Questão 27 --
--------------------------------------------------------------------------------

myunlines :: [String] -> String
myunlines []    = ""
myunlines [x]   = x++"\n"
myunlines (h:t) = h++"\n"++myunlines t

--------------------------------------------------------------------------------
-- Questão 28 --
--------------------------------------------------------------------------------

pMaior :: Ord a => [a] -> Int
pMaior [x] = 0
pMaior (h:t) | h == aux (h:t) = 0
             | otherwise = 1 + pMaior t
            where
              aux [x] = x
              aux (x:y:xs) | x>=y      = aux (x:xs)
                           | otherwise = aux (y:xs)

--------------------------------------------------------------------------------
-- Questão 29 --
---------------------- ----------------------------------------------------------

temRepetidos :: Eq a => [a] -> Bool
temRepetidos []    = False
temRepetidos (h:t) = elem h t || temRepetidos t

--------------------------------------------------------------------------------
-- Questão 30 --
--------------------------------------------------------------------------------

algarismos :: [Char] -> [Char]
algarismos [] = []
algarismos (h:t) | isDigit h = h:algarismos t
                 | otherwise = algarismos t

--------------------------------------------------------------------------------
-- Questão 31 --
--------------------------------------------------------------------------------

posImpares :: [a] -> [a]
posImpares [] = []
posImpares l = aux False l
             where
               aux _ [] = []
               aux True  (h:t) = h:aux False t
               aux False (h:t) = aux True t

--------------------------------------------------------------------------------
-- Questão 32 --
--------------------------------------------------------------------------------

posPares :: [a] -> [a]
posPares [] = []
posPares l = aux True l
             where
               aux _ [] = []
               aux True  (h:t) = h:aux False t
               aux False (h:t) = aux True t

--------------------------------------------------------------------------------
-- Questão 33 --
--------------------------------------------------------------------------------

isSorted :: Ord a => [a] -> Bool
isSorted []  = True
isSorted [x] = True
isSorted (x:y:xs) | x > y     = False
                  | otherwise = isSorted (y:xs)

--------------------------------------------------------------------------------
-- Questão 34 --
--------------------------------------------------------------------------------

iSort :: Ord a => [a] -> [a]
iSort [] = []
iSort (h:t) = insert h (iSort t)

--------------------------------------------------------------------------------
-- Questão 35 --
--------------------------------------------------------------------------------

menor :: String -> String -> Bool
menor _ [] = False
menor [] _ = True
menor (x:xs) (y:ys) | ord x < ord y = True
                    | ord x > ord y = False
                    | otherwise     = menor xs ys

--------------------------------------------------------------------------------
-- Questão 36 --
--------------------------------------------------------------------------------

elemMSet :: Eq a => a -> [(a,Int)] -> Bool
elemMSet x [] = False
elemMSet x ((y,n):ys) | x==y      = True
                      | otherwise = elemMSet x ys

--------------------------------------------------------------------------------
-- Questão 37 --
--------------------------------------------------------------------------------

lengthMSet :: [(a,Int)] -> Int
lengthMSet [] = 0
lengthMSet ((y,n):ys) = n + lengthMSet ys

--------------------------------------------------------------------------------
-- Questão 38 --
--------------------------------------------------------------------------------

converteMSet :: [(a,Int)] -> [a]
converteMSet [] = []
converteMSet ((y,n):ys) = aux (y,n) ++ converteMSet ys
                       where
                         aux (y,0) = []
                         aux (y,n) = [y]++aux (y,n-1)

--------------------------------------------------------------------------------
-- Questão 39 --
--------------------------------------------------------------------------------

insereMSet :: Eq a => a -> [(a,Int)] -> [(a,Int)]
insereMSet e [] = [(e,1)]
insereMSet e ((y,n):ys) | e == y = ((y,n+1):ys)
                        | otherwise = (y,n):insereMSet e ys

--------------------------------------------------------------------------------
-- Questão 40 --
--------------------------------------------------------------------------------

removeMSet :: Eq a => a -> [(a,Int)] -> [(a,Int)]
removeMSet _ [] = []
removeMSet e ((y,n):ys) | (e==y) && (n>1)  = ((y,n-1):ys)
                        | (e==y) && (n==1) = ys
                        | otherwise        = (y,n):removeMSet e ys

--------------------------------------------------------------------------------
-- Questão 41 --
--------------------------------------------------------------------------------

constroiMSet :: Ord a => [a] -> [(a,Int)]
constroiMSet l = aux 1 l
               where
                 aux i [x] = [(x,i)]
                 aux i (x:y:xs) | x==y = aux (i+1) (x:xs)
                                | x/=y = (x,i):aux 1 (y:xs)


--------------------------------------------------------------------------------
-- Questão 42 --
--------------------------------------------------------------------------------

mypartitionEithers :: [Either a b] -> ([a],[b])
mypartitionEithers l = (left l, right l)
                    where
                      left  (Left a :t)   = a : left t
                      left  (Right b :t)  = left t
                      left _  = []
                      right (Left a :t)   = right t
                      right (Right a :t)  = a : right t
                      right _ = []

--------------------------------------------------------------------------------
-- Questão 43 --
--------------------------------------------------------------------------------

catMaybes :: [Maybe a] -> [a]
catMaybes [] = []
catMaybes (Just a : xs)  = a : catMaybes xs
catMaybes (Nothing : xs) = catMaybes xs

--------------------------------------------------------------------------------
-- Questão 44 --
--------------------------------------------------------------------------------

data Movimento = Norte | Sul | Este | Oeste
               deriving Show

posicao :: (Int, Int) -> [Movimento] -> (Int, Int)
posicao (x,y) []        = (x,y)
posicao (x,y) (Norte:r) = posicao (x,y+1) r
posicao (x,y) (Sul:r)   = posicao (x,y-1) r
posicao (x,y) (Este:r)  = posicao (x+1,y) r
posicao (x,y) (Oeste:r) = posicao (x-1,y) r


--------------------------------------------------------------------------------
-- Questão 45 --
--------------------------------------------------------------------------------

caminho :: (Int,Int) -> (Int,Int) -> [Movimento]
caminho (x1,y1) (x2,y2) | x1==x2 && y1==y2 = []
                        | x1<x2            = [Este] ++ caminho (x1+1,y1) (x2,y2)
                        | x1>x2            = [Oeste] ++ caminho (x1,y1) (x2+1,y2)
                        | y1<y2            = [Norte] ++ caminho (x1,y1+1) (x2,y2)
                        | y1>y2            = [Sul] ++ caminho (x1,y1) (x2,y2+1)

--------------------------------------------------------------------------------
-- Questão 46 --
--------------------------------------------------------------------------------

vertical :: [Movimento] -> Bool
vertical []         = True
vertical (Norte:xs) = vertical xs
vertical (Sul:xs)   = vertical xs
vertical _          = False

--------------------------------------------------------------------------------
-- Questão 47 --
--------------------------------------------------------------------------------

data Posicao = Pos Int Int
               deriving Show

maisCentral :: [Posicao] -> Posicao
maisCentral [x] = x
maisCentral (x:y:t) | aux x <= aux y = maisCentral (x:t)
                    | aux x >  aux y = maisCentral (y:t)
                  where
                    aux (Pos k m) = sqrt(fromIntegral(k^2+m^2))


--------------------------------------------------------------------------------
-- Questão 48 --
--------------------------------------------------------------------------------

vizinhos :: Posicao -> [Posicao] -> [Posicao]
vizinhos _ [] = []
vizinhos (Pos x y) ((Pos z w):t) = if (y == w && x == (z+1)) || (y == w && x == (z-1)) || (x == z && y == (w+1)) || (x == z && y == (w-1))
                                   then (Pos z w):vizinhos (Pos x y) t
                                   else vizinhos (Pos x y) t

--------------------------------------------------------------------------------
-- Questão 49 --
--------------------------------------------------------------------------------

mesmaOrdenada :: [Posicao] -> Bool
mesmaOrdenada [x] = True
mesmaOrdenada ((Pos x y):(Pos z w):t) = if y==w
                                        then mesmaOrdenada ((Pos z w):t)
                                        else False

--------------------------------------------------------------------------------
-- Questão 50 --
--------------------------------------------------------------------------------

data Semaforo = Verde | Amarelo | Vermelho
                deriving Show

interseccaoOK :: [Semaforo] -> Bool
interseccaoOK l = (aux l)<=1
              where
                aux [Vermelho] = 0
                aux [Verde] = 1
                aux [Amarelo] = 1
                aux (Vermelho:resto) = aux resto
                aux (Verde:resto) = 1+aux resto
                aux (Amarelo:resto) = 1+aux resto
